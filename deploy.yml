# .github/workflows/deploy.yml
name: CI/CD Pipeline for Employee App (Fargate)

on:
  push:
    branches:
      - main # Trigger on pushes to the main branch

env:
  AWS_REGION: ap-south-1 # Your AWS region

jobs:
  ci:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Required for OIDC authentication with AWS
      contents: read # Required to checkout code

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9' # Or your application's Python version, matching your Flask app

      - name: Install Python dependencies
        run: pip install -r requirements.txt # Assumes you have a requirements.txt file in your repo root

      #- name: Run unit tests
      #run: pytest # Assumes you use pytest for your tests. Make sure you have test files.

      - name: Configure AWS credentials for ECR login
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.GH_ACTIONS_OIDC_ROLE_NAME }} # IAM Role for GitHub Actions
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Build and push Docker image to ECR
        uses: docker/build-push-action@v5
        with:
          context: . # Looks for Dockerfile in the root of your repository
          push: true
          tags: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/employee-app:latest,${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/employee-app:${{ github.sha }}

      # Optional but Recommended: Add Docker image vulnerability scanning here (e.g., Trivy)
      # - name: Scan Docker image for vulnerabilities
      #   uses: aquasecurity/trivy-action@master
      #   with:
      #     image-ref: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/employee-app:${{ github.sha }}
      #     format: 'table'
      #     exit-code: '1' # Fail if critical vulnerabilities are found
      #     ignore-unfixed: true
      #     severity: 'CRITICAL,HIGH'

  cd_infrastructure_and_db_init:
    runs-on: ubuntu-latest
    needs: ci # This job will only run if the 'ci' job completes successfully
    permissions:
      id-token: write # Required for OIDC authentication with AWS
      contents: read # Required to checkout code for Terraform files

    # Define outputs that can be consumed by subsequent jobs
    outputs:
      ecs_cluster_name: ${{ steps.get-tf-outputs.outputs.ecs_cluster_name }}
      ecs_service_name: ${{ steps.get-tf-outputs.outputs.ecs_service_name }}
      private_subnet_az1_id: ${{ steps.get-tf-outputs.outputs.private_subnet_az1_id }}
      private_subnet_az2_id: ${{ steps.get-tf-outputs.outputs.private_subnet_az2_id }}
      ecs_fargate_sg_id: ${{ steps.get-tf-outputs.outputs.ecs_fargate_sg_id }}
      db_init_task_definition_arn: ${{ steps.get-tf-outputs.outputs.db_init_task_definition_arn }}
      db_init_task_role_arn: ${{ steps.get-tf-outputs.outputs.db_init_task_role_arn }}
      vpc_id: ${{ steps.get-tf-outputs.outputs.vpc_id }}
      ecr_repository_url: ${{ steps.get-tf-outputs.outputs.ecr_repository_url }} # Useful for main app taskdef update later

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0 # Specify a compatible Terraform version

      - name: Configure AWS credentials for Terraform and ECS commands
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.GH_ACTIONS_OIDC_ROLE_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Terraform Init
        # Replace placeholders in main.tf with actual secret values before init
        run: |
          sed -i "s/your-terraform-state-bucket-unique-name/${{ secrets.TF_STATE_BUCKET_NAME }}/g" main.tf
          sed -i "s/your-terraform-state-lock-table/${{ secrets.TF_STATE_LOCK_TABLE_NAME }}/g" main.tf
          terraform init -backend-config="bucket=${{ secrets.TF_STATE_BUCKET_NAME }}" -backend-config="key=employee-app/terraform.tfstate" -backend-config="region=${{ env.AWS_REGION }}" -backend-config="dynamodb_table=${{ secrets.TF_STATE_LOCK_TABLE_NAME }}"

      - name: Terraform Apply (Provision/Update Infrastructure)
        run: terraform apply -auto-approve # -auto-approve skips the manual confirmation. Use with caution in production.

      - name: Get Terraform Outputs
        id: get-tf-outputs # ID for this step to retrieve its outputs
        run: |
          echo "ecs_cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "ecs_service_name=$(terraform output -raw ecs_service_name)" >> $GITHUB_OUTPUT
          echo "private_subnet_az1_id=$(terraform output -raw private_subnet_az1_id)" >> $GITHUB_OUTPUT
          echo "private_subnet_az2_id=$(terraform output -raw private_subnet_az2_id)" >> $GITHUB_OUTPUT
          echo "ecs_fargate_sg_id=$(terraform output -raw ecs_fargate_sg_id)" >> $GITHUB_OUTPUT
          echo "db_init_task_definition_arn=$(terraform output -raw db_init_task_definition_arn)" >> $GITHUB_OUTPUT
          echo "db_init_task_role_arn=$(terraform output -raw db_init_task_role_arn)" >> $GITHUB_OUTPUT
          echo "vpc_id=$(terraform output -raw vpc_id)" >> $GITHUB_OUTPUT
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT

      - name: Run DB Init Fargate Task
        run: |
          # The DB_PASSWORD is passed as an override to the task's environment.
          # This is necessary because Psql client expects PGPASSWORD env variable for non-interactive login.
          # The DB_MASTER_PASSWORD secret is securely passed from GitHub Actions to the Fargate task.
          aws ecs run-task \
            --cluster ${{ steps.get-tf-outputs.outputs.ecs_cluster_name }} \
            --task-definition ${{ steps.get-tf-outputs.outputs.db_init_task_definition_arn }} \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[${{ steps.get-tf-outputs.outputs.private_subnet_az1_id }},${{ steps.get-tf-outputs.outputs.private_subnet_az2_id }}],securityGroups=[${{ steps.get-tf-outputs.outputs.ecs_fargate_sg_id }}],assignPublicIp=DISABLED}" \
            --started-by "github-actions-db-init" \
            --overrides '{"containerOverrides":[{"name":"db-init-container","environment":[{"name":"PGPASSWORD","value":"${{ secrets.DB_MASTER_PASSWORD }}"}]}]}' \
            --wait-for-task-stops # Wait for the task to complete its job

  cd_application_deployment:
    runs-on: ubuntu-latest
    needs: cd_infrastructure_and_db_init # This job depends on infrastructure and DB init completing
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/${{ secrets.GH_ACTIONS_OIDC_ROLE_NAME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update ECS Service with new image
        run: |
          aws ecs update-service \
            --cluster ${{ needs.cd_infrastructure_and_db_init.outputs.ecs_cluster_name }} \
            --service ${{ needs.cd_infrastructure_and_db_init.outputs.ecs_service_name }} \
            --task-definition employee-app-task \
            --force-new-deployment # Forces ECS to launch new tasks with the latest task definition version

      # Optional: Add post-deployment smoke/integration tests here
      # - name: Run Post-Deployment Smoke Tests
      #   run: |
      #     # Example: curl http://${{ needs.cd_infrastructure_and_db_init.outputs.alb_dns_name }}/health
      #     # Add actual API calls to verify application functionality after deployment
